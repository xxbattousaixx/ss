{"ast":null,"code":"import { LinearFilter, MeshBasicMaterial, NearestFilter, RGBAFormat, ShaderMaterial, UniformsUtils, WebGLRenderTarget } from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { AfterimageShader } from \"../shaders/AfterimageShader.js\";\n\nvar AfterimagePass = function (damp) {\n  Pass.call(this);\n  if (AfterimageShader === undefined) console.error(\"AfterimagePass relies on AfterimageShader\");\n  this.shader = AfterimageShader;\n  this.uniforms = UniformsUtils.clone(this.shader.uniforms);\n  this.uniforms[\"damp\"].value = damp !== undefined ? damp : 0.96;\n  this.textureComp = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  });\n  this.textureOld = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  });\n  this.shaderMaterial = new ShaderMaterial({\n    uniforms: this.uniforms,\n    vertexShader: this.shader.vertexShader,\n    fragmentShader: this.shader.fragmentShader\n  });\n  this.compFsQuad = new Pass.FullScreenQuad(this.shaderMaterial);\n  var material = new MeshBasicMaterial();\n  this.copyFsQuad = new Pass.FullScreenQuad(material);\n};\n\nAfterimagePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AfterimagePass,\n  render: function (renderer, writeBuffer, readBuffer) {\n    this.uniforms[\"tOld\"].value = this.textureOld.texture;\n    this.uniforms[\"tNew\"].value = readBuffer.texture;\n    renderer.setRenderTarget(this.textureComp);\n    this.compFsQuad.render(renderer);\n    this.copyFsQuad.material.map = this.textureComp.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.copyFsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.copyFsQuad.render(renderer);\n    } // Swap buffers.\n\n\n    var temp = this.textureOld;\n    this.textureOld = this.textureComp;\n    this.textureComp = temp; // Now textureOld contains the latest image, ready for the next frame.\n  },\n  setSize: function (width, height) {\n    this.textureComp.setSize(width, height);\n    this.textureOld.setSize(width, height);\n  }\n});\nexport { AfterimagePass };","map":{"version":3,"sources":["/Users/dc7/Desktop/SS/node_modules/three/examples/jsm/postprocessing/AfterimagePass.js"],"names":["LinearFilter","MeshBasicMaterial","NearestFilter","RGBAFormat","ShaderMaterial","UniformsUtils","WebGLRenderTarget","Pass","AfterimageShader","AfterimagePass","damp","call","undefined","console","error","shader","uniforms","clone","value","textureComp","window","innerWidth","innerHeight","minFilter","magFilter","format","textureOld","shaderMaterial","vertexShader","fragmentShader","compFsQuad","FullScreenQuad","material","copyFsQuad","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","texture","setRenderTarget","map","renderToScreen","clear","temp","setSize","width","height"],"mappings":"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","sourcesContent":["import {\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { AfterimageShader } from \"../shaders/AfterimageShader.js\";\n\nvar AfterimagePass = function ( damp ) {\n\n\tPass.call( this );\n\n\tif ( AfterimageShader === undefined )\n\t\tconsole.error( \"AfterimagePass relies on AfterimageShader\" );\n\n\tthis.shader = AfterimageShader;\n\n\tthis.uniforms = UniformsUtils.clone( this.shader.uniforms );\n\n\tthis.uniforms[ \"damp\" ].value = damp !== undefined ? damp : 0.96;\n\n\tthis.textureComp = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\n\n\t\tminFilter: LinearFilter,\n\t\tmagFilter: NearestFilter,\n\t\tformat: RGBAFormat\n\n\t} );\n\n\tthis.textureOld = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\n\n\t\tminFilter: LinearFilter,\n\t\tmagFilter: NearestFilter,\n\t\tformat: RGBAFormat\n\n\t} );\n\n\tthis.shaderMaterial = new ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: this.shader.vertexShader,\n\t\tfragmentShader: this.shader.fragmentShader\n\n\t} );\n\n\tthis.compFsQuad = new Pass.FullScreenQuad( this.shaderMaterial );\n\n\tvar material = new MeshBasicMaterial();\n\tthis.copyFsQuad = new Pass.FullScreenQuad( material );\n\n};\n\nAfterimagePass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: AfterimagePass,\n\n\trender: function ( renderer, writeBuffer, readBuffer ) {\n\n\t\tthis.uniforms[ \"tOld\" ].value = this.textureOld.texture;\n\t\tthis.uniforms[ \"tNew\" ].value = readBuffer.texture;\n\n\t\trenderer.setRenderTarget( this.textureComp );\n\t\tthis.compFsQuad.render( renderer );\n\n\t\tthis.copyFsQuad.material.map = this.textureComp.texture;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.copyFsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t\tthis.copyFsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Swap buffers.\n\t\tvar temp = this.textureOld;\n\t\tthis.textureOld = this.textureComp;\n\t\tthis.textureComp = temp;\n\t\t// Now textureOld contains the latest image, ready for the next frame.\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis.textureComp.setSize( width, height );\n\t\tthis.textureOld.setSize( width, height );\n\n\t}\n\n} );\n\nexport { AfterimagePass };\n"]},"metadata":{},"sourceType":"module"}