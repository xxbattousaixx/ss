{"ast":null,"code":"import { Matrix4, Vector2 } from \"../../../build/three.module.js\";\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nvar SSAOShader = {\n  defines: {\n    \"PERSPECTIVE_CAMERA\": 1,\n    \"KERNEL_SIZE\": 32\n  },\n  uniforms: {\n    \"tDiffuse\": {\n      value: null\n    },\n    \"tNormal\": {\n      value: null\n    },\n    \"tDepth\": {\n      value: null\n    },\n    \"tNoise\": {\n      value: null\n    },\n    \"kernel\": {\n      value: null\n    },\n    \"cameraNear\": {\n      value: null\n    },\n    \"cameraFar\": {\n      value: null\n    },\n    \"resolution\": {\n      value: new Vector2()\n    },\n    \"cameraProjectionMatrix\": {\n      value: new Matrix4()\n    },\n    \"cameraInverseProjectionMatrix\": {\n      value: new Matrix4()\n    },\n    \"kernelRadius\": {\n      value: 8\n    },\n    \"minDistance\": {\n      value: 0.005\n    },\n    \"maxDistance\": {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tNormal;\", \"uniform sampler2D tDepth;\", \"uniform sampler2D tNoise;\", \"uniform vec3 kernel[ KERNEL_SIZE ];\", \"uniform vec2 resolution;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float kernelRadius;\", \"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n  \"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n  \"varying vec2 vUv;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"}\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec2 screenPosition ) {\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tfloat viewZ = getViewZ( depth );\", \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\", \"\tvec3 viewNormal = getViewNormal( vUv );\", \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\", \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\", // compute matrix used to reorient a kernel vector\n  \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\", \"\tvec3 bitangent = cross( viewNormal, tangent );\", \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\", \" float occlusion = 0.0;\", \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\", \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n  \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n  \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n  \"\t\tsamplePointNDC /= samplePointNDC.w;\", \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n  \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n  \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n  \"\t\tfloat delta = sampleDepth - realDepth;\", \"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n  \"\t\t\tocclusion += 1.0;\", \"\t\t}\", \"\t}\", \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\", \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAODepthShader = {\n  defines: {\n    \"PERSPECTIVE_CAMERA\": 1\n  },\n  uniforms: {\n    \"tDepth\": {\n      value: null\n    },\n    \"cameraNear\": {\n      value: null\n    },\n    \"cameraFar\": {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"varying vec2 vUv;\", \"#include <packing>\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getLinearDepth( vUv );\", \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAOBlurShader = {\n  uniforms: {\n    \"tDiffuse\": {\n      value: null\n    },\n    \"resolution\": {\n      value: new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 texelSize = ( 1.0 / resolution );\", \"\tfloat result = 0.0;\", \"\tfor ( int i = - 2; i <= 2; i ++ ) {\", \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\", \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\", \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nexport { SSAOShader, SSAODepthShader, SSAOBlurShader };","map":{"version":3,"sources":["/Users/dc7/Desktop/DAC/ss/node_modules/three/examples/jsm/shaders/SSAOShader.js"],"names":["Matrix4","Vector2","SSAOShader","defines","uniforms","value","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"mappings":"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","sourcesContent":["import {\n\tMatrix4,\n\tVector2\n} from \"../../../build/three.module.js\";\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nvar SSAOShader = {\n\n\tdefines: {\n\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t\"KERNEL_SIZE\": 32\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tNormal\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"tNoise\": { value: null },\n\t\t\"kernel\": { value: null },\n\t\t\"cameraNear\": { value: null },\n\t\t\"cameraFar\": { value: null },\n\t\t\"resolution\": { value: new Vector2() },\n\t\t\"cameraProjectionMatrix\": { value: new Matrix4() },\n\t\t\"cameraInverseProjectionMatrix\": { value: new Matrix4() },\n\t\t\"kernelRadius\": { value: 8 },\n\t\t\"minDistance\": { value: 0.005 },\n\t\t\"maxDistance\": { value: 0.05 },\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tNormal;\",\n\t\t\"uniform sampler2D tDepth;\",\n\t\t\"uniform sampler2D tNoise;\",\n\n\t\t\"uniform vec3 kernel[ KERNEL_SIZE ];\",\n\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\"uniform float kernelRadius;\",\n\t\t\"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\t\"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\"}\",\n\n\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"float getViewZ( const in float depth ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\n\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\n\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\n\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\n\t\t\"}\",\n\n\t\t\"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n\n\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\"\tfloat viewZ = getViewZ( depth );\",\n\n\t\t\"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n\t\t\"\tvec3 viewNormal = getViewNormal( vUv );\",\n\n\t\t\" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n\t\t\"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n\n\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n\t\t\"\tvec3 bitangent = cross( viewNormal, tangent );\",\n\t\t\"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n\n\t\t\" float occlusion = 0.0;\",\n\n\t\t\" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n\n\t\t\"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n\t\t\"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n\n\t\t\"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n\t\t\"\t\tsamplePointNDC /= samplePointNDC.w;\",\n\n\t\t\"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n\n\t\t\"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n\t\t\"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n\t\t\"\t\tfloat delta = sampleDepth - realDepth;\",\n\n\t\t\"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n\n\t\t\"\t\t\tocclusion += 1.0;\",\n\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n\n\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nvar SSAODepthShader = {\n\n\tdefines: {\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\n\tuniforms: {\n\n\t\t\"tDepth\": { value: null },\n\t\t\"cameraNear\": { value: null },\n\t\t\"cameraFar\": { value: null },\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tfloat depth = getLinearDepth( vUv );\",\n\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nvar SSAOBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new Vector2() }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 texelSize = ( 1.0 / resolution );\",\n\t\t\"\tfloat result = 0.0;\",\n\n\t\t\"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n\n\t\t\"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n\n\t\t\"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n\t\t\"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nexport { SSAOShader, SSAODepthShader, SSAOBlurShader };\n"]},"metadata":{},"sourceType":"module"}