{"ast":null,"code":"import { AdditiveBlending, Color, LinearFilter, MeshBasicMaterial, RGBAFormat, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  Pass.call(this);\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (var i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error(\"UnrealBloomPass relies on LuminosityHighPassShader\");\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n  this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (var i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n  this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error(\"UnrealBloomPass relies on CopyShader\");\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms[\"opacity\"].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this.oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new Pass.FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function () {\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (var i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    this.oldClearColor.copy(renderer.getClearColor());\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n    this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n    this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        \"KERNEL_RADIUS\": kernelRadius,\n        \"SIGMA\": kernelRadius\n      },\n      uniforms: {\n        \"colorTexture\": {\n          value: null\n        },\n        \"texSize\": {\n          value: new Vector2(0.5, 0.5)\n        },\n        \"direction\": {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n      fragmentShader: \"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}\"\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new ShaderMaterial({\n      defines: {\n        \"NUM_MIPS\": nMips\n      },\n      uniforms: {\n        \"blurTexture1\": {\n          value: null\n        },\n        \"blurTexture2\": {\n          value: null\n        },\n        \"blurTexture3\": {\n          value: null\n        },\n        \"blurTexture4\": {\n          value: null\n        },\n        \"blurTexture5\": {\n          value: null\n        },\n        \"dirtTexture\": {\n          value: null\n        },\n        \"bloomStrength\": {\n          value: 1.0\n        },\n        \"bloomFactors\": {\n          value: null\n        },\n        \"bloomTintColors\": {\n          value: null\n        },\n        \"bloomRadius\": {\n          value: 0.0\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n      fragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}\"\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"sources":["/Users/dc7/Desktop/DAC/ss/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"names":["AdditiveBlending","Color","LinearFilter","MeshBasicMaterial","RGBAFormat","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","call","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","basic","fsQuad","FullScreenQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius"],"mappings":"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","sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = function ( resolution, strength, radius, threshold ) {\n\n\tPass.call( this );\n\n\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t// create color only once here, reuse it later inside the render function\n\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t// render targets\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round( this.resolution.x / 2 );\n\tvar resy = Math.round( this.resolution.y / 2 );\n\n\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\tvar renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\trenderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\tvar renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\trenderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\tresx = Math.round( resx / 2 );\n\n\t\tresy = Math.round( resy / 2 );\n\n\t}\n\n\t// luminosity high pass material\n\n\tif ( LuminosityHighPassShader === undefined )\n\t\tconsole.error( \"UnrealBloomPass relies on LuminosityHighPassShader\" );\n\n\tvar highPassShader = LuminosityHighPassShader;\n\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = threshold;\n\tthis.highPassUniforms[ \"smoothWidth\" ].value = 0.01;\n\n\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t} );\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\tvar resx = Math.round( this.resolution.x / 2 );\n\tvar resy = Math.round( this.resolution.y / 2 );\n\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\n\t\tresy = Math.round( resy / 2 );\n\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\tthis.compositeMaterial.uniforms[ \"blurTexture1\" ].value = this.renderTargetsVertical[ 0 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture2\" ].value = this.renderTargetsVertical[ 1 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture3\" ].value = this.renderTargetsVertical[ 2 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture4\" ].value = this.renderTargetsVertical[ 3 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture5\" ].value = this.renderTargetsVertical[ 4 ].texture;\n\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = strength;\n\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\tthis.compositeMaterial.uniforms[ \"bloomFactors\" ].value = bloomFactors;\n\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ),\n\t\t\t\t\t\t\t new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t// copy material\n\tif ( CopyShader === undefined ) {\n\n\t\tconsole.error( \"UnrealBloomPass relies on CopyShader\" );\n\n\t}\n\n\tvar copyShader = CopyShader;\n\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\n\tthis.materialCopy = new ShaderMaterial( {\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.basic = new MeshBasicMaterial();\n\n\tthis.fsQuad = new Pass.FullScreenQuad( null );\n\n};\n\nUnrealBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: UnrealBloomPass,\n\n\tdispose: function () {\n\n\t\tfor ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tvar resx = Math.round( width / 2 );\n\t\tvar resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t},\n\n\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t},\n\n\tgetSeperableBlurMaterial: function ( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"direction\": { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}\"\n\t\t} );\n\n\t},\n\n\tgetCompositeMaterial: function ( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}\"\n\t\t} );\n\n\t}\n\n} );\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"]},"metadata":{},"sourceType":"module"}